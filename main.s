// -*- assembler -*-
// Enable the alternate macro extensions
  .altmacro

  // Defines "printf" which prints to STDOUT
  .include "print.s"

// Extremely basic enum implementation with macros
.macro enum_reset
  .set enum_idx, 0
  .section .rodata
.endm

.macro opt name
  LOCAL namelbl
  .set \name, enum_idx
  .set enum_idx, enum_idx+1
  .data
namelbl:
  .asciz "name"
  .section .rodata
  .8byte namelbl
.endm

.macro exit status
  mov rdi, status
  mov rax, SYS_EXIT
  syscall
  movb [0], 1
.endm

  .set STRINGS_BUF_CAP, 1048576
  .comm strings_buf_len, 8
  .comm strings_buf, STRINGS_BUF_CAP

  .text
  // Loop over our strings buffer and see if we find the string somewhere in it
	// already
string_finalize:
  push r8
  push r9
  mov r8, rax # Save the incoming string variable
  // Terminate the string with a null
  mov rbx, strings_buf_len
  movb strings_buf[rbx], 0
  // Loop over the strings which we have seen so far
  mov r9, 0
_string_finalize_loop:
  lea rax, strings_buf[r9]
  cmp r8, rax
  jae _string_finalize_notfound
  // Compare strings
  mov rax, r8
  lea rbx, strings_buf[r9]
  call strcmp
  cmp rax, 0
  je _string_finalize_match
  inc r9
  jmp _string_finalize_loop
_string_finalize_match:
  // Free the unnecessary string
  sub r8, offset strings_buf
  mov strings_buf_len, r8
  // Return the found string
  lea rax, strings_buf[r9]
  ret
_string_finalize_notfound:
  mov rax, r8
  ret

strcmp:
  mov cl, [rax]
  mov dl, [rbx]
  cmp cl, dl
  jne _strcmp_ne
  cmp cl, 0
  je _strcmp_cl0
  cmp dl, 0
  je _strcmp_ne
  inc rax
  inc rbx
  jmp strcmp
_strcmp_cl0:
  cmp dl, 0
  je _strcmp_eq
_strcmp_ne:
  mov rax, 1
  ret
_strcmp_eq:
  mov rax, 0
  ret

  enum_reset
enum_TOKEN:
  opt TOK_EOF
  opt TOK_EQ
  opt TOK_EQEQ
  opt TOK_ADD
  opt TOK_SUB
  opt TOK_MUL
  opt TOK_DIV
  opt TOK_DOT
  opt TOK_NOT
  opt TOK_AND
  opt TOK_OR
  opt TOK_COMMA
  opt TOK_LT
  opt TOK_GT

  opt TOK_LPAREN
  opt TOK_RPAREN
 	opt TOK_LBRACKET
  opt TOK_RBRACKET
  opt TOK_LBRACE
  opt TOK_RBRACE


  opt TOK_STR
  opt TOK_CHAR
  opt TOK_INT
  opt TOK_IDENT

  // Buffer space for read char lookahead
  // These are all initialized as 0, which is a legal state,
  // as there are 0 bytes in the buffer, and 0 bytes behind the cursor
  .set INPUT_BUF_SIZE, 256
  .comm input_buffer, INPUT_BUF_SIZE
  .comm input_cursor, 8
  .comm input_end, 8

  // Look at the upcoming character in the buffer. This must be called after at
	// least one call to next_chr.
peek_chr:
  mov rcx, input_cursor
  cmp rcx, -1
  je _peek_chr_eof
  xor rax, rax
  mov al, [input_buffer+rcx]
  ret
_peek_chr_eof:
  mov rax, -1
  ret

next_chr:
  incq input_cursor
  mov rax, input_end
  cmpq input_cursor, rax
  jb _next_chr_done
_next_chr_read:
  movq input_cursor, 0
  mov rax, SYS_READ
  mov rdi, STDIN
  lea rsi, input_buffer
  mov rdx, INPUT_BUF_SIZE
  syscall
  cmp rax, 0
  jg _next_chr_done
_next_chr_eof:
  movq input_cursor, -1
_next_chr_done:
  movq input_end, rax
  ret

  .data
_next_token_jmptbl:
  // Include the generated table lexjmptbl.s. This table is generated by the
  // python script gen_lexjmptbl.py
  .include "lexjmptbl.s"

  .comm token_type, 8
  .comm token_data, 8

.macro token_combine chr, label
  LOCAL no_match, match
  call peek_chr
  cmp rax, chr
  jne no_match
match:
  call next_chr
  jmp label
no_match:
.endm

.macro token_ret tok, data
  movq token_data, data
  movq token_type, tok
  ret
.endm

  .text
next_token:
_next_token_ignore:
  call peek_chr
  cmp rax, -1
  je _next_token_eof
  cmp rax, 127
  ja _next_token_invalid

  push rax # Preserve the current char value
  call next_chr
  pop rax

  jmp [_next_token_jmptbl+rax*8]
_next_token_eof:
  token_ret TOK_EOF, 0
_next_token_invalid:
  mov rax, 60
  mov rdi, 1
  syscall
  ret
_next_token_ident:
  // Save the first char
  mov rcx, strings_buf_len
  lea rdx, strings_buf[rcx]
  jmp _next_token_ident_start
_next_token_ident_loop:
  call next_chr
  mov rcx, strings_buf_len
_next_token_ident_start:
  movb strings_buf[rcx], al
  incq strings_buf_len
  call peek_chr
  cmp rax, '_'
  je _next_token_ident_loop
  cmp rax, 'a'
  jb _next_token_ident_done
  cmp rax, 'z'
  jbe _next_token_ident_loop
  cmp rax, 'A'
  jb _next_token_ident_done
  cmp rax, 'Z'
  jbe _next_token_ident_loop
_next_token_ident_done:
  mov rax, rdx
  call string_finalize
  mov rbx, rax
  mov rax, TOK_IDENT
  ret
_next_token_int:
  sub rax, '0'
  mov rbx, rax
  push rbx
  jmp _next_token_int_start
_next_token_int_loop:
  imul rbx, 10
  sub rax, '0'
	add rbx, rax
  push rbx
  call next_chr
_next_token_int_start:
  call peek_chr
  pop rbx
  cmp rax, '0'
  jl _next_token_int_done
  cmp rax, '9'
  jle _next_token_int_loop
_next_token_int_done:
  // rbx already contains the value
  mov rax, TOK_INT
  ret
_next_token_str:
	// Save the first char
  mov rcx, strings_buf_len
  lea rdx, strings_buf[rcx]
_next_token_str_loop:
  mov rcx, strings_buf_len
  movb strings_buf[rcx], al
  incq strings_buf_len
  call peek_chr
  cmp rax, 34 # 34 is double quote
  je _next_token_str_done
  cmp rax, '\\'
  je _next_token_str_special

  jmp _next_token_str_loop
_next_token_str_special:
  // XXX: IMPLEMENT
  jmp _next_token_str_loop
_next_token_str_done:
  mov rax, rdx
  call string_finalize
  mov rbx, rax
  mov rax, TOK_STR
  ret
_next_token_char:
  printf "Looking at a char start...\n"
  exit 0
_next_token_eq:
  token_combine '=', _next_token_eqeq
  token_ret TOK_EQ, 0
_next_token_eqeq:
  token_ret TOK_EQEQ, 0
_next_token_add:
  token_ret TOK_ADD, 0
_next_token_sub:
  token_ret TOK_SUB, 0
_next_token_mul:
  token_ret TOK_MUL, 0
_next_token_div:
  token_ret TOK_DIV, 0
_next_token_dot:
  token_ret TOK_DOT, 0
_next_token_not:
  token_ret TOK_NOT, 0
_next_token_and:
  token_ret TOK_AND, 0
_next_token_or:
  token_ret TOK_OR, 0
_next_token_lparen:
  token_ret TOK_LPAREN, 0
_next_token_rparen:
  token_ret TOK_RPAREN, 0
_next_token_lbracket:
  token_ret TOK_LBRACKET, 0
_next_token_rbracket:
  token_ret TOK_RBRACKET, 0
_next_token_lbrace:
  token_ret TOK_LBRACE, 0
_next_token_rbrace:
  token_ret TOK_RBRACE, 0
_next_token_comma:
  token_ret TOK_COMMA, 0
_next_token_lt:
  token_ret TOK_LT, 0
_next_token_gt:
  token_ret TOK_GT, 0

  .global _start
_start:
  call next_chr
  call next_token
  mov rax, token_type
  push [enum_TOKEN + rax*8]
  printf "next token is %s\n"
  mov rdi, rax
  mov rax, 60
  syscall
